
SUB MakePlanets (star_Name$,star_MassKSP,star_RadiusKSP,parentInclination,Max_num_planets,planet_distanceMax,star_FrostLineM):
	'# Planet Gen Start
	'#Note that star_FrostLineM is in meters
	maxPlanets = INT(RND * Max_num_planets) '#how many planets in this system?
	'maxPlanets = INT(RND * 10) '#how many planets in this system? Max of 10
	'#maxPlanets = 10
	IF maxPlanets > 0 THEN
		planetNumb = 1		
		theSemiMajorAxis = 0
		planet_distanceMin = simpleRocheLimit(star_MassKSP)*1000
		planet_distanceMin = simpleRocheLimit(1.7565459e28)*1000
		FOR aPlanet = 1 TO maxPlanets
			'########################
			'#Start out by seeing if the planet is in the LWHZ.
			'#That will determine the template that should be used
			'#STH 2019-0111
			theVariance = 1.4+(RND(1)*(2-1.4))
			IF NOT(theSemiMajorAxis = 0) then
				theSemiMajorAxis = (theSemiMajorAxis * theVariance)
				'#Spacing between planets should be a factor of between 1.4 and 2
				'#theSemiMajorAxis = theSemiMajorAxis+(theSemiMajorAxis * 1.5) 'should be a value between 1.4 and 2.0
			END IF 
			IF theSemiMajorAxis = 0 then
				theSemiMajorAxis = (planet_distanceMin*theVariance)
				'#let the first planet fall somewhere between the roche limit and the frostline'
				'#theSemiMajorAxis = planet_distanceMin + (planet_distanceMin*(RND(1) * (star_FrostLineM- planet_distanceMin)))
			END IF 
			'#What are the limits?
			'#planet_distanceMax is passed in
			'#star_FrostLineM is passed in
			inLWHZ = innerLWHZ(star_MassKSP)
			outLWHZ = outerLWHZ(star_MassKSP)
			inLMHZ = innerLMHZ(star_MassKSP)
			outLMHZ = outerLMHZ(star_MassKSP)
			'#################
			'#See if the planet falls within the liquid water habitable zone
			isInLWHZ$ = "FALSE"
			if (theSemiMajorAxis>inLWHZ and theSemiMajorAxis<outLWHZ) then
				isInLWHZ$ = "TRUE"
			end if
			'#################
			'#See if the planet falls within the liquid methane habitable zone
			isInLMHZ$ = "FALSE"
			if (theSemiMajorAxis>inLMHZ and theSemiMajorAxis<outLMHZ) then
				isInLMHZ$ = "TRUE"
			end if




			'########################'
			if isInLWHZ$ = "FALSE" then
				'#Pick a random planet template from what is read in'
				keyIndex = 1 + INT(RND * (UBOUND(planetKey$))) 'want the range to be from 1 to end. Index 0 is the header
				PLANETTYPE$ = planetKey$(keyIndex)
				PLANETDESC$ = thePlanetDesc$(keyIndex)
				PLANETRADIUS = thePlanetRadius(keyIndex)
				PLANETMASS = thePlanetMass(keyIndex)
				PLANETSTOCK$ = thePlanetStock$(keyIndex)
				PLANETSOI = thePlanetSOI(keyIndex) 'really, this should be calculated from mass'
				'########################'
				'###Fill in basic body data'
				IF PLANETSTOCK$ = "TRUE" THEN
					aBodyNode$ = "Body"+chr$(13)
					templateNode$ = "Template"+chr$(13)+"        {"+chr$(13)+"            name = "+ PLANETTYPE$+chr$(13)+"        }"
				END IF
				'# ELSE statements don't seem to work in included code
				IF NOT (PLANETSTOCK$ = "TRUE") THEN
					aBodyNode$ = "+Body[" + PLANETTYPE$ + "]"+chr$(13)
					templateNode$ = ""
				END IF
			end if
			if isInLWHZ$ = "TRUE" then
				'#Limit to the laythe template for now.
				'#Should eventually be able to use Kerbin, Eve, or Laythe
				PLANETTYPE$ = "Laythe"
				PLANETDESC$ = ""
				PLANETRADIUS = 600000
				PLANETMASS = 5.2915158E+22
				PLANETSTOCK$ = "TRUE"
				PLANETSOI = kspSOI(star_MassKSP, PLANETMASS, theSemiMajorAxis)
				aBodyNode$ = "Body"+chr$(13)
				templateNode$ = "Template"+chr$(13)+"        {"+chr$(13)+"            name = "+ PLANETTYPE$+chr$(13)+"            removePQSMods = PQSLandControl,VertexHeightMap,PQSCity,VertexHeightNoise,VertexHeightNoiseVertHeight,VertexSimplexHeightMap"+chr$(13)+"        }"
			end if

			'########################'
			'###Planet name
			'#2017-0201 STH This could be turned into a CSV file of roman numerals read into an array
			IF planetNumb = 1 THEN PNM$ = "I"
			IF planetNumb = 2 THEN PNM$ = "II"
			IF planetNumb = 3 THEN PNM$ = "III"
			IF planetNumb = 4 THEN PNM$ = "IV"
			IF planetNumb = 5 THEN PNM$ = "V"
			IF planetNumb = 6 THEN PNM$ = "VI"
			IF planetNumb = 7 THEN PNM$ = "VII"
			IF planetNumb = 8 THEN PNM$ = "VIII"
			IF planetNumb = 9 THEN PNM$ = "IX"
			IF planetNumb = 10 THEN PNM$ = "X"
			thePlanetName$ = star_Name$ +" "+ PNM$
			'########################'
			'###Fill in orbit data'
			theReferenceBody$ = star_Name$
			theColour$ = ""
			theMode$ = ""
			'#the inclination of the planet should be close to the plane of the parent star
			'#https://en.wikipedia.org/wiki/Orbital_inclination
			tempVar=int(rnd*0.5)
			theInclination$=str$(int(parentInclination+tempVar))
			'#allow rare planets to have orbits that deviate a lot from the orbital planet'
			if RND>0.9 then
				tempVar=int(rnd*45.0)
				theInclination$=str$(parentInclination+tempVar)
			end if
			theEccentricity$ = ""

			theLongitudeOfAscendingNode$ = "0"
			theArgumentOfPeriapsis$ = STR$(INT(RND * 1000))
			theMeanAnomalyAtEpoch$ = STR$(0)
			theEpoch$ = STR$(0)
			'########################'
			'###Fill in property data'
			'#moved the property data code to take advantage of orbital values in description'
			if PLANETDESC$ = "" then
				PLANETDESC$ = "Semimajor axis:\\nn "+str$(theSemiMajorAxis)+"m\\nn \\nnArg. of periapsis: "+theArgumentOfPeriapsis$+"째\\nn \\nnInclination: "+theInclination$+"째\\nn \\nnTidal locked: unknown\\nn \\nnLWH zone: "+isInLWHZ$
			end if
			aPropertiesTemplate$ = thePropertiesTemplate$
			'#(aTemplate$, theDescription$, theRadius$, theMass$, theGravParam$, theGeeASL$, theDoesRotate$, theRotationPeriod$, theInitialRotation$, theIsTidallyLocked$, theIsHomeWord$, inLWHZ$, inLMHZ$, theSOI$)
			aPropertiesNode$ = propertyNode$(aPropertiesTemplate$, PLANETDESC$, STR$(PLANETRADIUS), STR$(PLANETMASS), "", "", "", "", "", "", "", isInLWHZ$, isInLMHZ$, STR$(PLANETSOI))
			'########################'
			aOrbitTemp$ = theOrbitTemplate$
			aOrbitNode$ = orbitNode$(aOrbitTemp$, theReferenceBody$, theColour$, theMode$, theInclination$, theEccentricity$, STR$(theSemiMajorAxis), theLongitudeOfAscendingNode$, theArgumentOfPeriapsis$, theMeanAnomalyAtEpoch$, theEpoch$)		
			'########################'
			'###10% chance of having a ring
			RINGS = INT(RND * 10)
			'RINGS = 0
			IF RINGS = 0 THEN
				'#theAngle$ = "0"
				theAngle$ = theInclination$
				theOuterRadius$ = "3000"
				theInnerRadius$ = "2000"
				theRingTexture$ = ltrim$(str$(INT(RND * 3) + 1))
				theColour$ = "1.0,0.1,0.1,1.0"
				theLockRotation$ = "false"
				theUnlit$ = "false"
				aRingsTemp$ = theRingsTemplate$
				aRingNode$ = ringNode$(aRingsTemp$, theAngle$, theOuterRadius$, theInnerRadius$, theRingTexture$, theColour$, theLockRotation$, theUnlit$)
			END IF

			'########################''
			'###ScaledVersion template
			if isInLWHZ$ = "TRUE" then
				aScaledVersionNode$ = theScaledVersionTemplate$
			end if
			'########################'


			


			'########################'
			'###Ocean template
			if isInLWHZ$ = "TRUE" then
				aOceanNode$ = theOceanTemplate$
			end if



			'########################'
			'########################'
			'###PQS template	
			if isInLWHZ$ = "TRUE" then
				vertexSimplexHeightAbsoluteSeed$ = str$(int(RND * 200))
				vertexHeightNoiseSeed$ = str$(int(RND * 10))
				voronoiCratersSimplexSeed$ = str$(int(RND * 200000))
				voronoiCratersVoronoiSeed$ = str$(int(RND * 1000))
				'###city2 values
				city2Altitude$ = "-600000"
				city2Latitude$ = "0.0" '#str$((rnd*180)-90)
				city2Longitude$ = "0.0" '#str$((rnd*360)-180)
				city2isCommnetStation$ = "True"
				city2isKSC$ = "False"
				city2Name$ = thePlanetName$+"_test"
				city2ModelPath$ = "To-Boldly-Go/Data_Folder/models/Monolith"
				city2Scale$ ="100,100,100"

				aCity2Temp$ = theCity2Template$
				aCity2Node$ = city2Node$(aCity2Temp$, city2Altitude$, city2Latitude$, city2Longitude$, city2isCommnetStation$, city2isKSC$, city2Name$, city2ModelPath$, city2Scale$)

				aPQSTemp$ = thePQSTemplate$
				aPQSNode$ = PQSNode$(aPQSTemp$, vertexSimplexHeightAbsoluteSeed$, vertexHeightNoiseSeed$, voronoiCratersSimplexSeed$, voronoiCratersVoronoiSeed$, aCity2Node$)
			end if

			'########################'
			'########################'
			'###Debug template
			aDebugNode$ = theDebugTemplate$



			'########################'
			aPlanetTemp$ = thePlanetTemplate$
			'FUNCTION planetTempSubstitution$ (aTemplate$, aBodyNode$, aName$, aTemplateNode$, aPropertiesNode$, aOrbitNode$, aScaledVerionNode$, aRingNode$, aAtmosphereNode$, aPQSNode$, aOceanNode$, aDebugNode$)
			aPlanetTemp$ = planetTempSubstitution$ (aPlanetTemp$, aBodyNode$, thePlanetName$, templateNode$, aPropertiesNode$, aOrbitNode$, aScaledVersionNode$, aRingNode$, "", aPQSNode$, aOceanNode$, aDebugNode$)

			'#Clear out the nodes so they are not populated next iteration
			'#Failing to do so led to oddities with ocean and ring nodes appearing everywhere
			aBodyNode$ = ""
			templateNode$ = ""
			aPropertiesNode$ = ""
			aOrbitNode$ = ""
			aRingNode$ = ""
			aScaledVersionNode$ = ""
			aOceanNode$ = ""
			aPQSNode$ = ""
			aCity2Node$ = ""
			aDebugNode$ = ""
			print #1, aPlanetTemp$

			'########################
			'#add planet to the researchBody file
			ignoreLevels$ = ignoreLevels$ + "        "+thePlanetName$ +" = true false false false"+chr$(10)
			if PLANETRADIUS>=300500 then
				localizationText$ = localizationText$+ "        #autoLOC_RBodies_discovery_"+thePlanetName$+ " = " + thePlanetName$ + " -- Orbiting: "+star_Name$+"\\nn  \\nnSemimajor axis: "+str$(theSemiMajorAxis)+"m\\nn \\nnArg. of periapsis: "+theArgumentOfPeriapsis$+"째\\nn \\nnInclination: "+theInclination$+"째\\nn \\nnTidal locked: unknown\\nn \\nnHabitable zone: unknown"+chr$(10)
				
				discoveryText$ = discoveryText$+"        #autoLOC_RBodies_discovery_"+thePlanetName$+chr$(10)
    		end if
    		if PLANETRADIUS<300500 then
				discoveryText$ = discoveryText$+"        //"+thePlanetName$+" is too small"+chr$(10)
			end if
			'########################'
			'####
			'#25% chance of there being a moon
			CALL MakeMoons (thePlanetName$,parentInclination,PLANETRADIUS,4)
			
			planetNumb = planetNumb + 1
			POBJECTNUMBER = POBJECTNUMBER + 1

		NEXT

		IF ASTTOG$ = "y" THEN
			CALL MakeAsteroids(star_Name$,2)
		END IF
	END IF
	
		
END SUB